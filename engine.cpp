// engine.cpp

#include "engine.h"
#include "fen.h"
#include "search.h"

#include <sstream>
#include <random>
#include <chrono>
#include <vector>
#include <iostream>

BoardData getInitialBoard() {
    BoardData board;
    const char* init =
        "rnbqkbnr"
        "pppppppp"
        "........"
        "........"
        "........"
        "........"
        "PPPPPPPP"
        "RNBQKBNR";

    for (int i = 0; i < 64; ++i)
        board.pieces[i] = init[i];
    board.whiteToMove = true;
    board.canCastleK = board.canCastleQ = board.canCastlek = board.canCastleq = true;
    board.enPassantTarget = -1;
    board.halfmoveClock = 0;
    board.fullmoveNumber = 1;
    return board;
}

BoardData applyMove(BoardData board, Move move) {
    int side = board.whiteToMove ? WHITE : BLACK;
    // No need for legality checks

    // Decode the given move
    int from = SQUARE(move.fromRow, move.fromCol);
    int to = SQUARE(move.toRow, move.toCol);
    char movingPiece = board.pieces[from];
    bool isCapture = board.pieces[to] != '.';

    // // If it is a book move (not generated by engine) then we need to check for castling and en passant captures.
    // // Is it a pawn moving to an empty square?
    // if ( (tolower(movingPiece) == 'p') || (board.PieceColor(to) == EMPTY) ) {
    //     // If it is making a capture then it must be en passant so set the flag
    //     if (side == WHITE && ((from - to) == 9 || (from - to) == 7)) move.isEnPassant = true;
    //     if (side == BLACK && ((to - from) == 9 || (to - from) == 7)) move.isEnPassant = true;
    // }
    // // Is it a King castling?
    // if (tolower(movingPiece) == 'k') {
    //     // If White is castling kingside set the flag.
    //     if ((board.canCastleK && board.whiteToMove) && (from == E1 && to == G1)) move.isCastling = true;
    //     // If White is castling queenside set the flag.
    //     if ((board.canCastleQ && board.whiteToMove) && (from == E1 && to == C1)) move.isCastling = true;
    //     // If Black is castling kingside set the flag.
    //     if ((board.canCastlek && !board.whiteToMove) && (from == E8 && to == G8)) move.isCastling = true;
    //     // If Black is castling queenside set the flag.
    //     if ((board.canCastleq && !board.whiteToMove) && (from == E8 && to == C8)) move.isCastling = true;
    // }

    // Handle en passant captures
    if (move.isEnPassant) {
        if (board.PieceColor(to) != EMPTY) 
            throw std::invalid_argument("Illegal en passant move attempted");
        // If the move is an en passant capture, then the move to square
        // is actually the square behind the pawn being captured and must be empty.
        // Regardless which colour is moving the captured pawn is on the same row as the from square
        // so remove the captured pawn from the board
        board.pieces[SQUARE(move.fromRow, move.toCol)] = '.';
        board.enPassantTarget = -1; // Clear en passant target after capture
        isCapture = true;
        // Piece move is done by normal piece move logic below
    }

    // Do the Piece move
    if (move.promotion != '\0') {
        // Handle promotion move
        if (board.whiteToMove) board.pieces[to] = toupper(move.promotion);
        else board.pieces[to] = tolower(move.promotion);
    } else {
        // Normal move, including en passant, just move the piece
        board.pieces[to] = movingPiece;
    }
    // Clear the piece from the original square
    board.pieces[from] = '.';

    if (move.isCastling) {
        // If castling, move the rook (the king is moved by the normal piece move logic above) and
        // lose all castling rights.
        if (to == G1) { board.pieces[H1] = '.'; board.pieces[F1] = 'R'; board.canCastleK = board.canCastleQ = false; }
        else if (to == C1) { board.pieces[A1] = '.'; board.pieces[D1] = 'R'; board.canCastleK = board.canCastleQ = false; }
        else if (to == G8) { board.pieces[H8] = '.'; board.pieces[F8] = 'r'; board.canCastlek = board.canCastleq = false; }
        else if (to == C8) { board.pieces[A8] = '.'; board.pieces[D8] = 'r'; board.canCastlek = board.canCastleq = false;}
    }

    // Update castling rights when necessary
    if (movingPiece == 'K') board.canCastleK = board.canCastleQ = false; // If White king moved then both castling rights are lost
    if (movingPiece == 'k') board.canCastlek = board.canCastleq = false; // If Black king moved then both castling rights are lost
    if (from == H1 && movingPiece == 'R') board.canCastleK = false; // If White rook on H1 moved then White cannot castle kingside
    if (from == A1 && movingPiece == 'R') board.canCastleQ = false; // If White rook on A1 moved then White cannot castle queenside
    if (from == H8 && movingPiece == 'r') board.canCastlek = false; // If Black rook on H8 moved then Black cannot castle kingside
    if (from == A8 && movingPiece == 'r') board.canCastleq = false; // If Black rook on A8 moved then Black cannot castle queenside

    board.enPassantTarget = -1; // Default to no en passant target
    // If the moving piece is a pawn and it moved two squares forward, set the en passant target
    if (tolower(movingPiece) == 'p' && abs(from - to) == 16)
        board.enPassantTarget = (from + to) / 2;

    // Reset halfmove clock if a pawn move or capture was made
    // Otherwise increment it to count the number of halfmoves since the last capture or pawn move
    if (tolower(movingPiece) == 'p' || isCapture)
        board.halfmoveClock = 0;
    else
        board.halfmoveClock++;

    // Update side to move.
    board.whiteToMove = !board.whiteToMove;

    // Increment fullmove number if Black just moved.
    if (board.whiteToMove) board.fullmoveNumber++;

    return board;
}

void parsePosition(const std::string& input, BoardData& board) {
    std::istringstream iss(input);
    std::string token;
    iss >> token;  // 'position'
    if (!(iss >> token)) return;

    if (token == "startpos") {
        board = getInitialBoard();
        if (iss >> token && token == "moves") {
            while (iss >> token) {
                int fromCol = token[0] - 'a';
                int fromRow = 8 - (token[1] - '0');
                int toCol = token[2] - 'a';
                int toRow = 8 - (token[3] - '0');
                char promo = (token.length() == 5) ? token[4] : '\0';
                board = applyMove(board, {fromRow, fromCol, toRow, toCol, false, false, promo});
            }
        }
    } else if (token == "fen") {
        std::string fen;
        std::string word;
        int count = 0;
        while (count < 6 && iss >> word) {
            fen += word + ' ';
            count++;
        }
        board = loadFEN(fen);

        if (iss >> token && token == "moves") {
            while (iss >> token) {
                int fromCol = token[0] - 'a';
                int fromRow = 8 - (token[1] - '0');
                int toCol = token[2] - 'a';
                int toRow = 8 - (token[3] - '0');
                char promo = (token.length() == 5) ? token[4] : '\0';
                board = applyMove(board, {fromRow, fromCol, toRow, toCol, false, false, promo});
            }
        }
    }
}

std::string moveToUci(const Move& m) {
    std::string uci;
    uci += 'a' + m.fromCol;
    uci += '8' - m.fromRow;
    uci += 'a' + m.toCol;
    uci += '8' - m.toRow;
    if (m.promotion) uci += tolower(m.promotion);
    return uci;
}

Move bookMoveToFullMove(const Move& m, BoardData board) {
    // A book move is not generated by engine so we need to check the position for castling and en passant captures.
    // Decode the given bookMove.
    int side = board.whiteToMove ? WHITE : BLACK;
    int from = SQUARE(m.fromRow, m.fromCol);
    int to = SQUARE(m.toRow, m.toCol);
    char movingPiece = board.pieces[from];
    // Initialise flags for the additional information we need to add.
    bool isEnPassant = false;
    bool isCastling = false;
    int newToCol = m.toCol; // Need to be able to change m.toCol if we are castling

    // Is it a pawn moving to an empty square?
    if ( (tolower(movingPiece) == 'p') && (board.PieceColor(to) == EMPTY) ) {
        // If it is making a capture then it must be en passant so set the flag
        // if (side == WHITE && ((from - to) == 9 || (from - to) == 7)) isEnPassant = true;
        // if (side == BLACK && ((to - from) == 9 || (to - from) == 7)) isEnPassant = true;
        isEnPassant = true;
    }
    
    // Is it a king move?
    if (tolower(movingPiece) == 'k') {
        // Castling moves are represented somewhat unconventially by Polyglot as follows:
        // white short      e1h1
        // white long       e1a1
        // black short      e8h8
        // black long       e8a8
        // If White is castling kingside set the flag.
        if ((board.canCastleK && board.whiteToMove) && (from == E1 && to == H1)) {
            isCastling = true;
            newToCol = FILE_G - 1; // Change destination to the Col for G file
        }
        // If White is castling queenside set the flag.
        if ((board.canCastleQ && board.whiteToMove) && (from == E1 && to == A1)) {
            isCastling = true;
            newToCol = FILE_C - 1; // Change destination to the Col for C file
        }
        // If Black is castling kingside set the flag.
        if ((board.canCastlek && !board.whiteToMove) && (from == E8 && to == H8)) {
            isCastling = true;
            newToCol = FILE_G - 1; // Change destination to the Col for G file
        }
        // If Black is castling queenside set the flag.
        if ((board.canCastleq && !board.whiteToMove) && (from == E8 && to == A8)) {
            isCastling = true;
            newToCol = FILE_C - 1; // Change destination to the Col for C file
        }
    }

    return { m.fromCol, m.fromRow, newToCol, m.toRow, isEnPassant, isCastling, m.promotion };
}

Move decodeUciMove(const std::string& uci) {
    if (uci.length() < 4 || uci.length() > 5) throw std::invalid_argument("Invalid UCI move format");
    int fromCol = uci[0] - 'a';
    int fromRow = 8 - (uci[1] - '0');
    int toCol = uci[2] - 'a';
    int toRow = 8 - (uci[3] - '0');
    char promotion = (uci.length() == 5) ? uci[4] : '\0';
    return {fromRow, fromCol, toRow, toCol, false, false, promotion};
}

namespace {
    int pieceToIndex(char p) {
        switch (p) {
            case 'P': return 0; case 'N': return 1; case 'B': return 2;
            case 'R': return 3; case 'Q': return 4; case 'K': return 5;
            case 'p': return 6; case 'n': return 7; case 'b': return 8;
            case 'r': return 9; case 'q': return 10; case 'k': return 11;
            default: return -1;
        }
    }
}

Zobrist::Zobrist() {
    std::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());
    for (int i = 0; i < 12; ++i)
        for (int j = 0; j < 64; ++j)
            pieceHash[i][j] = rng();
    whiteToMoveHash = rng();
    for (int i = 0; i < 4; ++i) castlingHash[i] = rng();
    for (int i = 0; i < 8; ++i) enPassantFileHash[i] = rng();
}

uint64_t Zobrist::computeHash(const BoardData& board) {
    uint64_t h = 0;
    for (int sq = 0; sq < 64; ++sq) {
        int idx = pieceToIndex(board.pieces[sq]);
        if (idx != -1) h ^= pieceHash[idx][sq];
    }
    if (board.whiteToMove) h ^= whiteToMoveHash;
    if (board.canCastleK) h ^= castlingHash[0];
    if (board.canCastleQ) h ^= castlingHash[1];
    if (board.canCastlek) h ^= castlingHash[2];
    if (board.canCastleq) h ^= castlingHash[3];
    if (board.enPassantTarget != -1)
        h ^= enPassantFileHash[board.enPassantTarget % 8];
    return h;
}
